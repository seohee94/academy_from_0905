절차형, 객체지향형, 함수형 프로그래밍으로 크게 구분 됨
자바조차 함수형 프로그래밍 형태로 변화하는 추세일 정도로 함수형 프로그래밍이 각광받고 있다

웹개발 방식은 JSP -> 프론트엔드(현재) -> MSA 순서로 변화하고 있음

프론트엔드/백엔드의 분리 : 화면과 데이터를 분리하는 것을 목적으로한다
분리가 안되는 MVP -> 분리되는 MVC -> 리액트(MVVM) 

제이쿼리의 패러다임 : 화면으로 화면을 조작
리액트/뷰의 패러다임 : 데이터로 화면을 조작

데이터 = 변수 = 상태(리액트/뷰에서)

** 프로그램 설치
GIT이 서버라면 totorise Git는 클라이언트의 역할

npm(뷰에서는 잘 사용 안함) = yarn(뷰에서 사용함)

webpack, babel, ESLint : 프론트 개발을 한다고 하면 세가지는 반드시 사용해야 함

브라우저는 es6는 인식하지 못한다. es5로만 인식한다. babel을 써야한다

뷰/리액트는 커맨드를 많이 쓴다

전통적인 방식
웹서버, was 서버는 분리된다. 웹서버는 정적인 이미지, 자바스크립트를 처리하고 was는 DB관련이다. 이유는 속도, 보안.

HTML은 자바스크립트와 같다. ==> 
HTML 태그에 있으면 자바스크립트에도 무조건 있다?
태그 = 객체 ex img 태그는 자바스크립트의 image객체가 된다
html의 속성은 자바스크립트 객체의 프로퍼티가 된다

DOM = document object model
BOM = browser object model 
--> 둘은 동일

뷰에서는 변수를 '상태'라고 부른다

** 함수의 작성 방법
표현식 > 선언식 (표현식을 사용하는것이 선언식을 사용하는 것 보다 낫다)

** 함수를 정의하는 여러가지 방법

선언식
function test(){} --> 파싱시 함수가 정의됨

표현식
var test = function(){} --> 실행시 함수가 정의됨

화살표
var test = (a, b) => {} --> 실행시 함수가 정의됨

동적함수
var test = new Function('x', 'y', 'return x+y');

** 메모리
힙영역 / 스택영역
객체의 경우 힙영역에 실제로 들어있고, 주소값이 스택 영역으로 들어간다
스택 입장에서 기본타입은 값이 바뀌어도 알수가 있는데, 참조타입은 알수가 없다 --> 따라서 직접 바꾸는 것은 혼란을 가중시킨다. 복제 후 바꿔서 주소까지 바꿀 수 있게 해야 혼란스럽지 않다 ('복제 후 할당' 기법)

스네이크 : _로 연결
파스칼 : 대문자로 시작
카멜 : 소문자로 시작 * 자바스크립트에서 사용
케밥 : -로 연결 (CSS)

11111 함수는 값이다 11111 -- 함수형 (*리액트와 뷰에서 함수형을 주로 쓴다)
라이브러리들이 클로저를 많이 쓴다 --> 함수를 실행해서 변수를 뱉었는데 그게 함수라서 또 다른 함수를 부르고...
제이쿼리도 클로저 기법을 사용해서 만들어진 프레임워크?

11111 함수는 객체다 11111 - 객체형
함수안에 함수가 있을 수 있다

함수에서의 this != 메서드에서의 this
표현식 함수의 this != 화살표 함수의 this

111111 화살표 함수를 만든 이유 111111
this를 쉽게 하기 위해

arr.splice(방번호, 삭제개수)

** slice와 splice 중에 삭제시 splice를 쓰는 이유 -> 복제 후 재할당에 적합. slice는 바로 삭제
** push는 사용해도 되지만 수업에서만 사용하지 않음?
arr[arr.length] = 값

대문자로 시작하는 함수를 생성자라고 약속했다 (ex. Array / Object)

미국은 script를 맨밑에 놓음

** 객체를 만드는 방법들
객체 리터럴 : var foo = {
			name : 'foo',
			run : function(){
				return this.namel
			}
		}

생성자 함수를 이용한 객체 선언 : 2019년 이후로는 리액트에서 사용안함. 뷰에서는 씀.
다트표기법 | foo.name : 브라우저 마다 에러를 뱉어내는 경우가 있을수 있음
대괄호표기법 | foo['name'] : 에러가 안나므로 이렇게 쓰는게 좋다

얕은 복사 : 주소값만 복사
깊은 복사 : 값을 복사??

뷰/리액트에서는 다중 셀렉트를 지원하지 않는다 (getElementBuId만 알면 된다)

** debugger
debugger;라고 쓴다 --> 크롬에서 breakpoint 대신에 디버깅 하는 법

ES6 아니고 ES2016이 정식명칭이다

webpack은 자동적으로 만들어 지는 거라 이제 필요없다
타입이 지정되는 자바스크립트인 타입스크립트가 리액트의 표준이 될 것 같다 ( 앵귤러는 타입스크립트가 베이스 )
리액트용 라이브러리는 대부분 타입스크립트로 만들어져 있음

얕은 복사로 인해 생기는 문제 참고

책은 챕터 5이전까지만 보기

vue default 2를 사용하는것이 좋다

pakage.json 중요, 만든 소스코드 파일들은 src에 넣는다

css html javascript를 분리하는게 웹표준이었는데, App.vue를 보면 알수있듯이 컴포넌트 방식으로 바뀌면서 하나의 파일에 다 넣는것으로 패러다임이 바뀌었다
-> 실습에서 익스플로러로 복붙했을때 웹팩이 사용되긴했는데 웹팩을 사용한것은 아님???

dist 폴더에 있는 것들을 실제 운영서버에 배포한다

